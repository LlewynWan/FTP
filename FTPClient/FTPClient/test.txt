#include"Client.h"
#include<sstream>
#include<fstream>

using namespace std;

void Client::prepare()
{
	/*初始化winsock*/
	WORD ws_version = MAKEWORD(2, 2);   //指定Winsock version
	WSADATA wsaData;                    //WSA 函数的参数
	WSAStartup(ws_version, &wsaData);

	//设置服务器的地址
	serverCommandAddr.sin_family = AF_INET;
	serverCommandAddr.sin_port = htons(21);
	inet_pton(AF_INET, SERVER_ADDR, &serverCommandAddr.sin_addr);

	//配置命令传输的socket
	commandSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
}
void Client::disconnect()
{
	closesocket(commandSocket);
	WSACleanup();
}
void Client::connectServer()
{
	if (connect(commandSocket, (SOCKADDR *)&serverCommandAddr, sizeof(serverCommandAddr)) == SOCKET_ERROR) {
		printf("发生错误\n");
	}
	else {
		printf("连接服务器成功\n");
	}
}


int Client::sendCommand()
{
	int len = command.size();
	for (int i = 0; i < len; i++) {
		sendbuf[i] = command[i];
	}
	sendbuf[len++] = '\r';
	sendbuf[len++] = '\n';

	int sendLen = 0;
	while (sendLen < len) {
		int r = send(commandSocket, sendbuf+sendLen, len-sendLen, 0);
		if (r == SOCKET_ERROR) {
			return SOCKET_ERROR;
		}
		sendLen += r;
	}
	return 0;
}

int Client::recvMessage()
{
	message = "";

	int curIndex = 0;
	int len;
	while ((len = recv(commandSocket, recvbuf + curIndex, sizeof(char) * (1024 - curIndex), 0)) != SOCKET_ERROR) {
		curIndex += len;
		if (recvbuf[curIndex - 1] == '\n' && recvbuf[curIndex - 2] == '\r') {
			for (int i = 0; i < curIndex - 2; i++) {
				message.push_back(recvbuf[i]);
			}
			cout << message << endl;
			return 0;
		}
	}
	return SOCKET_ERROR;
}

int Client::sendData()
{
	return 0;
}
int Client::recvData()
{
	message = "";

	int curIndex = 0;
	int len;
	while ((len = recv(dataSocket, recvbuf + curIndex, sizeof(char) * (1024-curIndex), 0)) != SOCKET_ERROR) {
		curIndex += len;
		if (recvbuf[curIndex - 1] == '\n' && recvbuf[curIndex - 2] == '\r') {
			for (int i = 0; i < curIndex - 2; i++) {
				message.push_back(recvbuf[i]);
			}
			return 0;
		}
	}
	return SOCKET_ERROR;
}



//设置用户名和密码
void Client::setUsername(string username)
{
	this->username = username;
}
void Client::setPassword(string password)
{
	this->password = password;
}

void Client::login()
{	
	if (recvMessage() != SOCKET_ERROR) {
		
	};
	
	command = "USER " + username;
	sendCommand();

	if (recvMessage() != SOCKET_ERROR)
		cout << message << endl;

	command = "PASS " + password;
	sendCommand();

	recvMessage();
}


/*
进入被动模式
*/
int Client::enterPassiveMode()
{
	command = "PASV";
	sendCommand();
	recvMessage();


	//解析服务器发送的数据
	string num[6];
	int i = 0, j = 0;
	while (message[i] != '(') i++;
	i++;
	int addrStart = i;
	while (1) {
		if (message[i] == ',' || message[i] == ')') {
			num[j++] = message.substr(addrStart, i - addrStart);
			addrStart = i + 1;
			if (message[i] == ')') break;
		}
		i++;
	}
	int num4 = 0, num5 = 0;
	for (int i = 0; i < num[4].size(); i++) {
		num4 *= 10;
		num4 += num[4][i] - '0';
	}
	for (int j = 0; j < num[5].size(); j++) {
		num5 *= 10;
		num5 += num[5][j] - '0';
	}
	//cout << num4 << ' ' << num5 << endl;

	/*for (int i = 0; i < 6; i++) {
		cout << num[i] << endl;
	}*/
	
	dataSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

	//设置数据连接的socket
	serverDataAddr.sin_family = AF_INET;
	serverDataAddr.sin_port = htons(256 * num4 + num5);
	inet_pton(AF_INET, SERVER_ADDR, &serverDataAddr.sin_addr);

	//cout << string("(" + num[0] + "." + num[1] + "." + num[2] + "." + num[3] + ")");

	if (connect(dataSocket, (SOCKADDR *)&serverDataAddr, sizeof(serverDataAddr)) == SOCKET_ERROR) {
		printf("发生错误\n");
	}
	else {
		printf("数据端口连接成功\n");
	}
	return 0;
}

//建立和断开数据连接
int Client::dataConnect(int mode)
{
	return enterPassiveMode();
}
int Client::dataDisconnect()
{
	closesocket(dataSocket);
	return 0;
}

/*
列出当前目录下的文件信息
*/
int Client::list()
{
	dataConnect(passiveMode);

	command = "LIST";
	sendCommand();
	recvMessage(); 

	//接收并且处理数据
	//由于这里不清楚不同服务器返回的信息会不会不同，不好解析
	recvData();
	cout << "目录下的文件信息如下:" << endl;
	cout << message << endl;
	
	//接收完成
	recvMessage();

	dataDisconnect();
	return 0;
}

/*
获取指定文件的大小
*/
int Client::fileSize(string fileName)
{
	command = "SIZE " + fileName;
	sendCommand();
	recvMessage();

	if (message.substr(0, 3) == "213") {
		stringstream ss(message);
		int size;
		ss >> size; 
		ss >> size; 
		cout << fileName + "文件大小为: " << size << "字节" << endl;
		return size;
	}
	else {
		cout << "发生错误" << endl;
		return 0;
	}
}


void writeFile(string fileName, char buf[], int len)
{
	ofstream out(fileName, ios::app);
	for (int i = 0; i < len; i++) {
		out << buf[i];
	}
	out.close();
}


int Client::downloadFile(string fileName, string directory)
{
	int size = fileSize(fileName);

	dataConnect(passiveMode);

	//首先创建新文件
	//注意要使用二进制模式读取文件
	ofstream newFile(directory + "//" + fileName, ios::trunc | ios::binary);

	command = "RETR " + fileName;
	sendCommand();
	recvMessage();

	memset(recvbuf, 0, sizeof(recvbuf));
	//接收文件
	int remainLen = size, len = 0, curIndex = 0;
	while ( remainLen > 0 ) {
		len = recv(dataSocket, recvbuf + curIndex, sizeof(char) * (1024 - curIndex), 0);
		if (len == SOCKET_ERROR) {
			cout << "出错了" << endl;
			return SOCKET_ERROR;
		}
		remainLen -= len;
		curIndex += len;

		if (curIndex == 1024) {
			newFile.write(recvbuf, curIndex);
			curIndex = 0;
		}
	}
	newFile.write(recvbuf, curIndex);

	//关闭文件
	newFile.close();
}	

void readFile(string fileName)
{
	char buf[1024];
	fill(buf, buf + 1024, 0);
	ifstream in(fileName);
	in.read(buf, 1024);
	cout << buf;

	cout << strlen(buf);
}


int Client::uploadFile(string fileName)
{
	dataConnect(passiveMode);
	
	cout << "发送文件：" << endl;
	command = "STOR " + fileName;
	sendCommand();
	recvMessage();

	cout << "打开要发送的文件" << endl;
	ifstream in(".//test.txt");
	memset(sendbuf, 0, sizeof(sendbuf));
	int curIndex = 0;
	int len = 0, lens = 0;
	while (!in.eof()) {
		curIndex = in.read(sendbuf, 1024).gcount();
		while ((len = send(dataSocket, sendbuf + lens, curIndex - lens, 0)) != SOCKET_ERROR && lens != curIndex) {
			lens += len;
		}
		lens = 0;
	}

	dataDisconnect();
	recvMessage();

	return 0;
}


